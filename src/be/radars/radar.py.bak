

import os
import math
import numpy as np
from typing import Dict, Optional, Callable, TypedDict
from radar_node_client import RadarNodeClient
from tracker_process import TrackerProcess

class TrackData(TypedDict):
    track_id: int
    azimuth: float
    range: float
    
class Radar:
    """Represents a single radar with its adapter client, tracker, and configuration"""
    CONFIG_RETRY_COUNT = 3
    
    def __init__(self, radar_id: str, host: str, http_port: int, tcp_port: int, 
                 radar_config: 'RadarConfiguration', azimuth: Optional[float] = None):
        self.radar_id = radar_id
        self.config = radar_config
        self.host = host  # ip address of the radar node server
        self.http_port = http_port  # http port of the radar node server
        self.tcp_port = tcp_port  # tcp port for detections data stream
        # installation azimuth angle of the radar
        if azimuth is None:
            self.azimuth = None
            self.rotation_matrix = None
        else:
            self.set_azimuth(azimuth)

        self.client = RadarNodeClient(radar_id, host, config_port=http_port, data_port=tcp_port)
        self.tracker_process = TrackerProcess(
            radar_id=self.radar_id,
            host=self.host,
            tcp_port=self.tcp_port,
            frame_period=1.0 / self.config.fps,
            on_tracked_targets=self.on_tracks_detect
        )

        # Dictionary to store radar data: radar_id -> TrackData
        self.radar_tracks: Dict[str, TrackData] = {}
        
    def start(self) -> bool:
        if self.configure(self.CONFIG_RETRY_COUNT):
            self.tracker_process.start()
            return True
        else:
            return False

    def set_azimuth(self, azimuth: float) -> None:
        self.azimuth = azimuth
        azimuth_rad = math.radians(azimuth)
        self.rotation_matrix = np.array([
            [math.cos(azimuth_rad), -math.sin(azimuth_rad)],
            [math.sin(azimuth_rad),  math.cos(azimuth_rad)]
        ])
    
    def configure(self, retries: int) -> bool:
        """Configure the radar with retry logic"""
        config = self.config.get_config()
        
        for attempt in range(1, retries + 1):
            try:
                response = self.client.send_command(config)
                if response == '"sensorStart"':
                    if attempt > 1:
                        print(f"radar {self.radar_id} configured successfully on attempt {attempt}")
                    else:
                        print(f"radar {self.radar_id} configured successfully")
                    return True
                else:
                    print(f"error configuring radar {self.radar_id} (attempt {attempt}/{retries}): {response}")
                    if attempt < retries:
                        print(f"retrying configuration for radar {self.radar_id}...")
            except Exception as e:
                print(f"exception configuring radar {self.radar_id} (attempt {attempt}/{retries}): {e}")
                if attempt < retries:
                    print(f"retrying configuration for radar {self.radar_id}...")
        
        # All retries failed
        print(f"failed to configure radar {self.radar_id} after {retries} attempts")
        return False
    
    def send_command(self, command: str) -> str:
        """Send a command to the radar"""
        return self.client.send_command(command)
    
    def health(self) -> bool:
        """Check if the radar is healthy"""
        return self.client.health()
    
    def get_data_reception_health(self) -> bool:
        """
        Get the health status based on whether the tracker process is receiving data.
        
        Returns:
            bool: True if data was received on TCP socket since last check, False otherwise
        """
        if self.tracker_process:
            return self.tracker_process.get_and_reset_health()
        return False
    def rotate_track(self, track) -> None:
        """
        Rotate a position (x, y) using this radar's rotation matrix.
        Uses numpy matrix multiplication for efficient computation.
        
        Args:
            track: The track to rotate
        """
        x, y, _ = track.get_position()
        if self.rotation_matrix is None:
            track.x, track.y = x, y
        
        else:
            position_vector = np.array([x, y])
            rotated_vector = self.rotation_matrix @ position_vector
            track.x, track.y = rotated_vector[0], rotated_vector[1]
    
    def stop(self) -> None:
        """Stop the radar's tracker process and client"""
        if self.tracker_process:
            self.tracker_process.stop()
        if self.client:
            self.client.stop()

    def on_tracks_detect(self, radar_id, tracks):
        if tracks:
            classified_tracks = [track for track in tracks if track.target_class and track.target_class != 'n']
            if len(classified_tracks) > 0:
                for track in classified_tracks:
                    self.rotate_track(track)
                    self.radar_tracks[radar_id] = {
                        "track_id": track.track_id,
                        "azimuth": track.azimuth,
                        "range": track.range_val
                    }
    
    def get_tracks(self) -> Dict[str, TrackData]:
        """
        Get a copy of the radar tracks dictionary and clear the original.
        
        Returns:
            Dict[str, TrackData]: Copy of the tracks before clearing
        """
        tracks_copy = self.radar_tracks.copy()
        self.radar_tracks.clear()
        return tracks_copy

class RadarConfiguration:
    RADAR_CONFIG_TEMPLATE = "./radar_config_template.cfg"

    def __init__(self, fps=20, 
                       chirp_start_freq=60, 
                       chirp_slope=18, 
                       cfar_range_threshold=6, 
                       cfar_doppler_threshold=6, 
                       cfar_min_range_fov=0, 
                       cfar_max_range_fov=85, 
                       cfar_min_doppler=-11, 
                       cfar_max_doppler=-0.2):
        self.fps = fps
        self.frame_period_ms = int(1000 / fps)
        self.chirp_start_freq = chirp_start_freq
        self.chirp_slope = chirp_slope
        self.cfar_range_threshold = cfar_range_threshold
        self.cfar_doppler_threshold = cfar_doppler_threshold
        self.cfar_min_range_fov = cfar_min_range_fov
        self.cfar_max_range_fov = cfar_max_range_fov
        self.cfar_min_doppler = cfar_min_doppler
        self.cfar_max_doppler = cfar_max_doppler

    def get_config(self) -> str:
        # Load the template file
        try:
            # Try to load from package resources first
            template_path = os.path.join(os.path.dirname(__file__), "radar_config_template.cfg")
            with open(template_path, 'r') as f:
                lines = f.readlines()
        except Exception:
            # Fallback to the hardcoded path
            with open(self.RADAR_CONFIG_TEMPLATE, 'r') as f:
                lines = f.readlines()
        
        # Replace template variables with actual values
        config_lines = []
        for line in lines:
            if line.startswith("%") or line.strip() == "":
                continue
            # Replace all template variables in the line
            line = line.format(
                chirp_start_freq=self.chirp_start_freq,
                chirp_slope=self.chirp_slope,
                frame_period_ms=self.frame_period_ms,
                cfar_range_threshold=self.cfar_range_threshold,
                cfar_doppler_threshold=self.cfar_doppler_threshold,
                cfar_min_range_fov=self.cfar_min_range_fov,
                cfar_max_range_fov=self.cfar_max_range_fov,
                cfar_min_doppler=self.cfar_min_doppler,
                cfar_max_doppler=self.cfar_max_doppler
            )
            config_lines.append(line.strip())

        return "\n".join(config_lines)
